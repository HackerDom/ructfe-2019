from sage.modules.free_module_integer import IntegerLattice

import os
import random
from base64 import b64decode, b64encode
from hashlib import md5
from json import dumps

import numpy as np
import requests

from api import API


HOSTNAME = 'localhost'
ALGO = 'lwe'

Q = 929
N = 16
R.<x> = PolynomialRing(GF(Q))

def uniform(n, lower, upper):
    return np.array([random.randint(lower, upper) for _ in range(n)], dtype=np.int)

def mymul(a, b):
    return vector(ZZ, np.array(list(a))*np.array(list(b)))

# Babai's Nearest Plane algorithm
def Babai_closest_vector(M, G, target):
    small = target
    for _ in xrange(1):
        for i in reversed(range(M.nrows())):
            c = ((small * G[i]) / (G[i] * G[i])).round()
            small -=  M[i] * c
    return target - small

# looks like http://mslc.ctf.su/wp/plaidctf-2016-sexec-crypto-300/, but no
def get_secrets(a, pk):
    mulA = matrix(ZZ, N, N)
    for i in range(N):
        tst = [0]*N
        tst[i] = 1
        mulA.set_row(i, mymul(tst, a))
    
    B = matrix(ZZ, 2*N, 2*N)
    B[:N,:N] = Q * identity_matrix(ZZ, N, N)
    B[N:,:N] = mulA
    B[N:,N:] = identity_matrix(ZZ, N, N)
    
    M = B.LLL()
    G = M.gram_schmidt()[0]
    print "= Done"

    target = vector(ZZ, list(pk) + [0] * N)
    res = Babai_closest_vector(M, G, target)
    delta = res - target
    s0 = vector(ZZ, delta[N:])
    s1 = vector(ZZ, target[:N] - res[:N])
    print "= s0 =", s0
    print "= s1 =", s1
    assert list((mymul(s0, a) + s1) % Q) == pk
    assert list((s0 * mulA + s1) % Q) == pk
    return list(s0), list(s1)

def get_pub_key(api, login):
    pub_key = api.get_pub_key(ALGO, login)
    return list(list(map(int, x.split(','))) for x in b64decode(pub_key['pub_key']).split(';'))

def put_flag(api, login, flag):
    signed = api.sign(ALGO, login, flag)
    return signed['s'], signed['h']

def get_flag(api, login, s, h):
    verified = api.verify(ALGO, login, s, h)
    return verified

def sign(msg, a, priv):
    s, e = map(np.array, priv)
    msg = np.array(map(ord, msg))
    y1 = uniform(N, -Q // 2, Q // 2)
    y2 = uniform(N, -Q // 2, Q // 2)
    w = (np.array(a)*y1 + y2) % Q
    c = (w + msg) % Q
    z1 = (s*c + y1) % Q
    z2 = (e*c + y2) % Q
    return c, z1, z2

def verify(msg, a, pub, s):
    pub = np.array(pub)
    msg = np.array(map(ord, msg))
    c, z1, z2 = s
    return all(c == ((np.array(a)*z1 + z2 - pub*c) + msg) % Q)

def exploit():
    login = os.urandom(5).encode('hex')
    flag = os.urandom(10).encode('hex') + '=='

    with API(HOSTNAME) as api:
        pub_key, a = get_pub_key(api, login)
        signature, h = put_flag(api, login, flag)
        s = list(list(map(int, x.split(','))) for x in b64decode(signature).split(';'))

        print verify(h.decode('hex'), a, pub_key, s)

        print login
        print h
        print signature
        fake_signature = sign(h.decode('hex'), a, get_secrets(a, pub_key))
        print verify(h.decode('hex'), a, pub_key, fake_signature)
        fake_signature = b64encode(b';'.join(b','.join(str(y) for y in x) for x in fake_signature))
        
        print fake_signature
        print get_flag(api, login, fake_signature, h)

if __name__ == '__main__':
    exploit()